ins# Central ERP Hub — Implementation Plan

Version: 1.0 | Created: November 19, 2025 | Owner: Sheheryar

Purpose: Turn the Master Blueprint into a concise, actionable implementation plan that covers backend, frontend, packages, system contracts, operational controls, and milestones. This plan prioritizes maximum Python for backend code, React for frontend, and JSON/CSS for data/ui assets.

---

## 1. High-level goals
- Implement a secure, modular Hub (infrastructure-only core) and first modules (Settings, KPI/Analytics, POS) using the blueprint.
- Use Python for most server/backend code; React for the frontend UI.
- Provide formal contracts: Unified Data API (OpenAPI), Module manifest schema, Sync protocol, and Backup/DR runbook.
- Ship dev tooling — SDK, manifest validator, contract tests, and CI templates.

## 2. Deliverables (initial scope)
- Hub core (Auth/Env Manager/Data API/Audit/Backup/Message Bus)
- Settings module (built-in) + sample module scaffold
- KPI & Prescriptive Engine (analytics) as first module (rule-based v1)
- POS (basic) module skeleton to connect to Hub
- Docs: `OpenAPI` summary, `manifest-schema.md`, `sync-protocol.md`, `backup-and-drrunbook.md`
- CI templates and contract-test suite

## 3. Architecture overview
- API layer: Python (FastAPI) — exposes Unified Data API and admin endpoints.
- Core services: Auth, RBAC, Audit Logger, Module Manager, Env Manager, Backup Service.
- DB Backends: SQLite (Standalone), MySQL (LAN), PostgreSQL (Cloud). Canonical schema in repo.
- Session/Message layer: Optional: Redis (session store + Redis Streams for lightweight message bus). Option to swap to RabbitMQ or NATS in larger deployments.
- Module runtime: containerized or isolated processes; optional WASM sandbox for 3rd-party modules.
- Frontend: React (single-page app). Minimal JS business logic; all heavy logic on backend.

Diagram (conceptual): Hub (FastAPI) ← Module Layer (separate containers/processes) ← Redis Streams / HTTP ← Frontend (React)

## 4. Backend stack (Python-first)
- Framework: FastAPI (async, OpenAPI generation)
- ASGI server: Uvicorn / Gunicorn (with uvicorn workers) for production
- ORM: SQLAlchemy (1.4+/2.0 style) + SQLModel or Pydantic models for DTOs
- Migrations: Alembic
- Auth: OAuth2 / JWT (python-jose) for tokens; optional session cookies for UI
- Password hashing: Passlib (bcrypt or argon2)
- Secrets/crypto: cryptography (for key management), integration adapters for KMS (AWS/Azure/GCP) as needed
- Message queue: Optional: Redis Streams (dev) + Redis pub/sub for simple messages; Celery or RQ as background job runner (Celery if RabbitMQ/Redis needed)
- Caching / sessions: Optional: Redis (dev)
- Task scheduling: APScheduler or Celery beat
- Serialization & validation: Pydantic
- Containerization: Dockerfiles for Hub and modules
- Package management: pip + constraints file; `requirements.txt` and `pyproject.toml` if desired

Recommended Python packages (initial):
- fastapi
- uvicorn[standard]
- sqlalchemy
- alembic
- pydantic
- sqlmodel (optional)
- passlib[bcrypt]
- python-jose[cryptography]
- cryptography
- redis
- celery (optional) or rq
- aioredis / redis-py
- pytest, httpx (tests)
- prometheus-client (metrics)
- structlog or loguru (structured logging)

## 5. Frontend stack (React + JSON + CSS)
- Framework: React (Vite or Create React App) — pure JavaScript (or TypeScript optional). The user asked for `react, json, css` — we'll keep React + CSS modules and JSON for data interchange.
- Styling: CSS Modules or Tailwind CSS (optional). Default: CSS Modules + BEM-friendly structure.
- State: React Query (for server state) or simple fetch + local state. Prefer React Query for caching and background refresh.
- Authentication: JWT via secure HttpOnly cookie or Authorization header. Login screen handled by React.
- Build: Vite recommended (fast dev experience)

Recommended frontend packages:
- react, react-dom
- react-router-dom
- axios or use native fetch (or use `@tanstack/react-query`)
- classnames (optional)
- tailwindcss (optional) or css modules
- storybook (optional) for UI components

UI/UX notes:
- Health Dashboard including `Connected Clients` panel (active sessions/devices)
- Admin-only actions for session termination, messages, and audit access
- Responsive: target 1366x768 and above; follow WCAG AA baseline

## 6. Data contract & artifacts
- Unified Data API: publish OpenAPI spec (auto-generated by FastAPI). Must include auth scopes and example payloads.
- Module manifest: JSON Schema + `manifest.yaml` examples. Fields: `name`, `version`, `api_version`, `capabilities`, `permissions`, `db_requirements`, `dependencies`, `signed_by`, `upgrade_path`.
- Sync protocol: document change-log based sync (CRDT option), conflict resolution rules, heartbeat intervals.
- Backups: logical DB dump format + config snapshots; encrypted & signed. DR runbook document.

Files to produce in repo (docs folder):
- `api/openapi.yaml` (summary)
- `manifests/manifest-schema.md`
- `ops/sync-protocol.md`
- `ops/backup-and-drrunbook.md`

## 7. Module model & isolation
- Modules register a manifest to Hub; Hub validates and issues scoped tokens.
- Module runtime options:
  - Preferred: run modules as separate Docker containers with limited capabilities and network policies.
  - Lightweight option: run as separate OS processes with SELinux/AppArmor or Windows job objects.
  - For untrusted third-party code, evaluate WASM sandbox.
- All module actions go through Unified Data API or Message Bus — no direct DB access by modules.

## 8. Sync & offline strategy (summary)
- Local change-log per store -> incremental deltas -> server reconciliation.
- Conflict strategy:
  - Use CRDTs for inventory counts (optional)
  - For business entities: last-write with version vectors OR manual merge UI for conflicting receipts/orders
- Heartbeat frequency & idle thresholds configurable (default heartbeat every 30s; active if last_activity <= 10 minutes)

## 9. Security & compliance
- Transport: TLS everywhere
- Secrets: DPAPI on Windows, KMS/HSM for cloud; secrets interface abstracts provider
- Passwords: bcrypt/argon2
- 2FA: optional TOTP
- Audit: append-only audit logs; restrict access; exportable
- Privacy: obfuscate IP/hostnames in UI by default; PII redaction in logs
- Compliance: provide guidance docs for PCI, GDPR, and local tax rules

## 10. Observability & testing
- Metrics: Prometheus instrumentation (`hub_active_sessions_total`, `hub_api_latency_seconds`, `hub_backup_status`)
- Logs: JSON structured logs (log level, module, user, request_id)
- Traces: optional OpenTelemetry (OTel) collector for traces
- Tests:
  - Unit tests (pytest)
  - Contract tests for modules (mock Hub)
  - Integration tests (docker-compose with SQLite/Postgres)
  - E2E tests (Cypress or Playwright optional)
- CI: GitHub Actions templates for PR checks, contract tests, and publish steps

## 11. Backup, DR & RTO/RPO
- Default RTO: 4 hours; default RPO: 1 hour (configurable per customer)
- Backup policy: daily (14d), weekly (12w), monthly (12m) — configurable
- Backups: DB logical dumps + config + manifests + key metadata; encrypted (AES-256) and signed
- Restore exercises: scheduled weekly automated restore in staging

## 12. Deployment & environment
- Environments: Standalone (single binary + SQLite), LAN (server + MySQL), Cloud (k8s or managed infra + Postgres)
- Dev: docker-compose for local dev (Hub, Redis, Postgres, Nginx)
- Production: Docker images; recommend k8s for cloud deployments; systemd services for on-prem

## 13. CI/CD & release strategy
- SemVer for Hub & modules
- Release workflow: feature branch -> PR -> automated tests -> merge -> build artifacts -> tag -> release
- Module registry: private registry (self-hosted) + public curated registry later

## 14. Timeline & milestones (initial 12 weeks)
- Week 0: Project setup, repos, dev environment, canonical schema repo
- Week 1–2: Core API skeleton (FastAPI), auth, RBAC, and OpenAPI baseline
- Week 3–4: DB migrations (Alembic), canonical schema, session/store heartbeat design
- Week 5–6: Module manifest schema, module installer, simple Settings module
- Week 7–8: Message bus plumbing (Redis Streams), audit logging, backup service
- Week 9–10: KPI Analytics module (rule-based), sample module integration tests
- Week 11: Health Dashboard (including Connected Clients panel), frontend components
- Week 12: CI templates, contract tests, restore exercise, release v0.1

## 15. Risks & mitigations
- Data-migration complexity: mitigate with strong migration tests and staging restores
- Malicious modules: require signing, sandboxing, and permissions review
- Offline sync conflicts: choose simple conflict strategy first; add CRDT later
- Scalability: design for scale from day one (Redis, connection pools, stateless API)

## 16. Suggested repo layout
- `/hub/` — backend services (FastAPI app, alembic migrations)
- `/modules/` — sample modules and scaffolds
- `/frontend/` — React app
- `/docs/` — OpenAPI, manifest schema, sync protocol, DR runbook
- `/devops/` — docker-compose, k8s manifests
- `/ci/` — CI templates

## 17. Next immediate actions (I can perform)
- Finish this doc and commit to the workspace (`implementation-plan.md`) — done.
- Draft `manifests/manifest-schema.md` (docs-only) — pick this to proceed.
- Draft `api/openapi-summary.md` (docs-only) — pick this to proceed.
- Draft `ops/sync-protocol.md` or `ops/backup-and-drrunbook.md` if you prefer.

---

End of implementation plan. Ask me which artifact to produce next (manifest schema, OpenAPI summary, sync protocol, or DR runbook).